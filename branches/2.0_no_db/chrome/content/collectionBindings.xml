<?xml version="1.0" encoding="UTF-8"?>
<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

    <binding id="mpmTreeBase">
        <handlers>
            <handler event="keypress" modifiers="accel" key="a"
                action="this.selectAll()"/>
            <handler event="dblclick"
                action="this.followItem(this.activeItem)"/>
            <handler event="keypress" keycode="VK_DELETE"
                action="this.delete()"/>
            <handler event="keypress" keycode="VK_RETURN"
                action="this.followItem(this.activeItem)"/>
        </handlers>
        <implementation>
            <field name="box">document.getAnonymousNodes(this)[0].boxObject</field>
            <field name="db"/>
            <field name="filter"/>
            <field name="treeNode">document.getAnonymousNodes(this)[0]</field>
            <field name="albumCol">document.getAnonymousElementByAttribute(this,'id','Album')</field>
            <field name="location"/>
            <property name="activeItem" readonly="true">
                <getter>
                    <![CDATA[
                    var v = Nz(this.view)
                    if (!v) return null
                    return v.rs[this.treeNode.currentIndex]
                    ]]>
                </getter>
            </property>
            <property name="sortDir">
                <getter>
                    var c = document.getAnonymousElementByAttribute(this,'id',this.sortOn);
                    if (!c) return null;
                    return c.getAttribute('sortDirection')
                </getter>
                <setter>
                    var c = document.getAnonymousElementByAttribute(this,'id',this.sortOn);
                    if (!c) return null;
                    if (val) c.setAttribute('sortDirection', val)
                    else c.removeAttribute('sortDirection')
                </setter>
            </property>
            <property name="sortOn">
                <getter>return this.treeNode.getAttribute('sortResource')</getter>
                <setter>this.treeNode.setAttribute('sortResource', val)</setter>
            </property>
            <constructor>
                this.treeNode = document.getAnonymousNodes(this)[0]
                this.box.QueryInterface(Components.interfaces.nsITreeBoxObject)
            </constructor>
            <method name="addAll">
                <body>
                    <![CDATA[
                    mpd.addToPlaylist(this.view.rs)
                    ]]>
                </body>
            </method>
            <method name="addSelected">
                <body>
                    <![CDATA[
                    var view = this.treeNode.view
                    var start = new Object();
                    var end = new Object();
                    var numRanges = view.selection.getRangeCount();

                    var db = []
                    for (var t=0; t<numRanges; t++){
                        view.selection.getRangeAt(t,start,end);
                        for (var v=start.value; v<=end.value; v++){
                            db.push(this.view.getCellValue(v,null))
                        }
                    }
                    mpd.addToPlaylist(db)
                    ]]>
                </body>
            </method>
            <method name="applyFilter">
                <parameter name="criteria"/>
                <body>
                    <![CDATA[
                    if (Nz(criteria,"")=="") {
                        this.view = new arrayView(this.db)
                        this.treeNode.view = this.view
                        return null
                    }
                    criteria = criteria.toLowerCase()
                    var test = function (element, index, array) {
                        return (element.Title.toLowerCase().indexOf(criteria) != -1)
                    }
                    var filterdb = this.db.filter(test)
                    this.view = new arrayView(filterdb)
                    this.treeNode.view = this.view
                    ]]>
                </body>
            </method>
            <method name="collapseOne">
                <parameter name="id"/>
                <body>
                    <![CDATA[
                    id = Nz(id)
                    var cols = this.treeNode.columns
                    if (id == 'Album') {
                        for (var i=0;i<cols.length;i++) {
                            var col = this.getCol(cols[i].id)
                            col.collapsed = (col.id == 'Album')
                        }
                    }
                    else {
                        for (var i=0;i<cols.length;i++) {
                            var col = this.getCol(cols[i].id)
                            col.collapsed = (col.id == id)
                        }
                    }
                    ]]>
                </body>
            </method>
            <method name="getCol">
                <parameter name="id"/>
                <body>
                    <![CDATA[
                    return document.getAnonymousElementByAttribute(this.treeNode,'id', id)
                    ]]>
                </body>
            </method>
            <method name="load">
                <parameter name="db"/>
                <parameter name="me"/>
                <body>
                    <![CDATA[
                    me = Nz(me,this)
                    me.sortDir = null
                    me.sortOn = null
                    me.filter = null
                    me.db = db
                    me.view = new arrayView(me.db)
                    me.treeNode.view = me.view
                    if (prefs.get("linguistic_sort", false)) me.sort("name")
                    me.treeNode.currentIndex = 0
                    ]]>
                </body>
            </method>
            <method name="selectAll">
                <body>
                    this.treeNode.view.selection.selectAll()
                </body>
            </method>
            <method name="sort">
                <parameter name="column"/>
                <body>
                    <![CDATA[
                    var smartsort = function (a,b) {
                        if (isNaN(a[column]+b[column])) {
                            var al = a[column].toLowerCase()
                            var bl = b[column].toLowerCase()
                            if (al>bl) return 1
                            if (al<bl) return -1
                            return 0
                        }
                        else { return a[column]-b[column]}
                    }
                    if (this.sortOn == column) {
                        switch (this.sortDir) {
                            case "ascending":
                                this.view.rs.reverse();
                                this.sortDir = 'descending';
                                break;
                            case "descending":
                                this.view.rs = this.db;
                                this.sortDir = null;
                                this.sortOn = null;
                                break;
                            default:
                                this.view.rs = copyArray(this.db).sort(smartsort);
                                this.sortDir = 'ascending';
                                break;
                        }
                    }
                    else {
                        this.view.rs = copyArray(this.db).sort(smartsort)
                        if (this.sortOn) this.sortDir = null
                        this.sortOn = column
                        this.sortDir = "ascending"
                    }
                    if (Nz(this.box)) this.box.invalidate()
                    ]]>
                </body>
            </method>
            <method name="saveCols">
                <body>
                <![CDATA[
                try {
                    var col= this.treeNode.columns.getFirstColumn()
                    var colprops = ""
                    var i = 1
                    while (col) {
                        if (colprops > "") colprops += ";"
                        if (col.id=='AlbumCover') {
                            colprops += [col.id, (col.hidden), col.width, i++].join(":")
                        } else {
                            colprops += [col.id, (col.width==0), col.width, i++].join(":")
                        }
                        col = col.getNext()
                    }
                    debug(colprops)
                    prefs.set("browser_columns", colprops)
                } catch (e) {
                    debug(e)
                }
                ]]>
                </body>
            </method>
        </implementation>
    </binding>

    <binding id="mpmBrowser" extends="#mpmTreeBase">
        <content>
            <xul:tree
                datasources="rdf:null"
                seltype="multiple"
                flags="dont-build-content"
                enableColumnDrag="true"
                flex="1">
                <xul:treecols>
                    <xul:treecol id="Pos" label="Position" ordinal="1" width="30px"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 tooltiptext="Playlist Position"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitPos" class="tree-splitter" ordinal="2" />
                    <xul:treecol id="Track" label="Track" ordinal="3" width="60px"
                                 persist="width ordinal hidden"
                                 collapsed="true"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitTrack" class="tree-splitter" ordinal="4" />
                    <xul:treecol id="Title" label="Title" ordinal="5" flex="2"
                                 persist="width ordinal hidden"
                                 overflow="true"
                                 class="sortDirectionIndicator"
                                 minwidth="120"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitTitle" class="tree-splitter" ordinal="6" />
                    <xul:treecol id="Time" label="Time" ordinal="7" width="60px"
                                 hidden="true"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitTime" class="tree-splitter" ordinal="8" />
                    <xul:treecol id="Album" label="Album" ordinal="9" flex="1"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitAlbum" class="tree-splitter" ordinal="10" />
                    <xul:treecol id="Artist" label="Artist" ordinal="11" flex="1"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitArtist" class="tree-splitter" ordinal="12" />
                    <xul:treecol id="Performer" label="Performer" ordinal="13" flex="1"
                                 hidden="true"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitPerf" class="tree-splitter" ordinal="14" />
                    <xul:treecol id="Composer" label="Composer" ordinal="15" flex="1"
                                 hidden="true"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitComp" class="tree-splitter" ordinal="16" />
                    <xul:treecol id="Genre" label="Genre" ordinal="17" flex="1"
                                 hidden="true"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitGenre" class="tree-splitter" ordinal="18" />
                    <xul:treecol id="Date" label="Date" ordinal="19" flex="1"
                                 hidden="true"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitDate" class="tree-splitter" ordinal="20" />
                    <xul:treecol id="name" label="[File]Name" ordinal="21" flex="1"
                                 hidden="true"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:splitter id="splitDisc" class="tree-splitter" ordinal="22" />
                    <xul:treecol id="Disc" label="Disc" ordinal="23" flex="1"
                                 hidden="true"
                                 persist="width ordinal hidden"
                                 class="sortDirectionIndicator"
                                 onclick="this.parentNode.parentNode.parentNode.sort(this.id)"/>
                    <xul:treecol id="AlbumCover" label="Cover/Actions" ordinal="24"
                                 collapsed="true"
                                 hidden="false"
                                 max-width="0"
                                 persist="width ordinal hidden"/>
                </xul:treecols>
                <xul:treechildren/>
            </xul:tree>
        </content>
    </binding>

    <binding id="mpmFoldersPane" extends="#mpmTreeBase">
        <content>
            <xul:tree
                datasources="rdf:null"
                flex="1"
                hidecolumnpicker="true"
                onselect="this.parentNode.followItem(this.parentNode.activeItem)">
                <xul:treecols height="0px">
                    <xul:treecol id="Title" hideheader="true" flex="1" primary="true"/>
                </xul:treecols>
                <xul:treechildren/>
            </xul:tree>
        </content>
        <implementation>
            <constructor>
                Components.utils.import("resource://minion/mpmUtils.js");
                Components.utils.import("resource://minion/mpd.js");
                Components.utils.import("resource://minion/trees.js");
                this.treeNode = document.getAnonymousNodes(this)[0]
                this.box = this.treeNode.boxObject;
                this.box.QueryInterface(Components.interfaces.nsITreeBoxObject)
                var me = this
                this.observer = {
                    observe: function(subject,topic,data){
                        if (!data) {
                            mpd.getAllDirs(function(db){me.load(db,me)})
                        }
                        else {
                            me.box.clearStyleAndImageCaches()
                            me.box.invalidate()
                        }
                    }
                };
                this.observer2 = {
                    observe: function(subject,topic,data){
                        if (data) {
                            mpd.getAllDirs(function(db){me.load(db,me)})
                        }
                    }
                };
                observerService.addObserver(this.observer,"updating_db",false)
                observerService.addObserver(this.observer2,"new_mpd_server",false)
            </constructor>
            <destructor>
                observerService.removeObserver(this.observer,"updating_db")
                observerService.removeObserver(this.observer2,"new_mpd_server")
            </destructor>
            <method name="load">
                <parameter name="db"/>
                <parameter name="me"/>
                <parameter name="rs">null</parameter>
                <body>
                    <![CDATA[
                    isRS = (rs != null) ? "true" : "false"
                    debug("folders.load(); cache=" + isRS)
                    me = Nz(me,this)
                    if (prefs.get("linguistic_sort", false)) {
                        var column = "Title"
                        var smartsort = function (a,b) {
                            if (isNaN(a[column]+b[column])) {
                                var al = a[column].toLowerCase()
                                var bl = b[column].toLowerCase()
                                if (al>bl) return 1
                                if (al<bl) return -1
                                return 0
                            }
                            else { return a[column]-b[column]}
                        }
                        if (!rs) {
                            debug("sort");
                            db.sort(smartsort)
                        }
                    }
                    me.view = new folderView(db, rs)
                    me.treeNode.view = me.view
                    ]]>
                </body>
            </method>
        </implementation>
    </binding>

    <binding id="mpmList" extends="#mpmTreeBase">
        <content>
            <xul:tree
                datasources="rdf:null"
                flex="1"
                hidecolumnpicker="true"
                onselect="this.parentNode.followItem(this.parentNode.activeItem)">
                <xul:treecols height="0px">
                    <xul:treecol id="Title" hideheader="true" flex="1" primary="true"/>
                </xul:treecols>
                <xul:treechildren/>
            </xul:tree>
        </content>
    </binding>

    <binding id="mpmTagsPane">
        <content>
            <xul:vbox flex="1">
                <xul:menulist id="tagsMainType"
                    onselect="this.parentNode.parentNode.loadMain()"
                    persist="selectedItem value">
                    <xul:menupopup>
                        <xul:menuitem label="Albums" value="album"/>
                        <xul:menuitem label="Artists" value="artist" selected="true"/>
                        <xul:menuitem label="Composers" value="composer"/>
                        <xul:menuitem label="Dates" value="date"/>
                        <xul:menuitem label="Genres" value="genre"/>
                        <xul:menuitem label="Performers" value="performer"/>
                    </xul:menupopup>
                </xul:menulist>
                <xul:textbox
                    id="filterText"
                    type="timed"
                    timeout="200"
                    oncommand="this.parentNode.parentNode.treeMain.applyFilter(this.value)"/>
                <xul:box
                    flex="3"
                    id="tagsMainTree"
                    style="-moz-binding: url('#mpmList')"
                    onselect="this.parentNode.parentNode.loadSub()"/>
                <xul:splitter collapse="after"/>
                <xul:vbox flex="1">
                    <xul:label class="tagsContentLabel" value="Related Items:"/>
                    <xul:menulist id="tagsSubType"
                        onselect="this.parentNode.parentNode.parentNode.loadSub()"
                        persist="selectedItem value">
                        <xul:menupopup>
                            <xul:menuitem label="Albums" value="album"/>
                            <xul:menuitem label="Artists" value="artist"/>
                            <xul:menuitem label="Composers" value="composer"/>
                            <xul:menuitem label="Dates" value="date"/>
                            <xul:menuitem label="Genres" value="genre"/>
                            <xul:menuitem label="Performers" value="performer"/>
                        </xul:menupopup>
                    </xul:menulist>
                    <xul:box
                        flex="1"
                        id="tagsSubTree"
                        style="-moz-binding: url('#mpmList')"/>
                </xul:vbox>
            </xul:vbox>
        </content>
        <implementation>
            <field name="filterText">document.getAnonymousElementByAttribute(this, 'id', 'filterText')</field>
            <field name="treeMain">document.getAnonymousElementByAttribute(this, 'id', 'tagsMainTree')</field>
            <field name="treeSub">document.getAnonymousElementByAttribute(this, 'id', 'tagsSubTree')</field>
            <field name="typeMain">document.getAnonymousElementByAttribute(this, 'id', 'tagsMainType')</field>
            <field name="typeSub">document.getAnonymousElementByAttribute(this, 'id', 'tagsSubType')</field>
            <constructor>
                Components.utils.import("resource://minion/mpmUtils.js");
                Components.utils.import("resource://minion/mpd.js");
                Components.utils.import("resource://minion/trees.js");
                var me = this
                this.observerServer = {
                    observe: function(subject,topic,data){
                        try {
                            var tree = me.treeMain
                            var filter = me.filterText.value
                            var q = new dbQuery()
                            q.type = me.typeMain.value
                            q.query = ""
                            q.execute(function(db){
                                tree.load(db,tree)
                                if (filter > "") tree.applyFilter(filter)
                            })
                            me.treeSub.load([],me.treeSub)
                        } catch (e) { debug(e) }
                    }
                };
                observerService.addObserver(this.observerServer,"new_connection",false)
            </constructor>
            <destructor>
            </destructor>
            <method name="loadMain">
                <body>
                    <![CDATA[
                    if (!mpd._socket) mpd.connect()
                    var tree = this.treeMain
                    var q = new dbQuery()
                    q.type = this.typeMain.value
                    q.query = ""
                    q.execute(function(db){tree.load(db,tree)})
                    ]]>
                </body>
            </method>
            <method name="loadSub">
                <body>
                    <![CDATA[
                    if (!this.treeMain.activeItem) return null
                    var tree = this.treeSub
                    var q = new dbQuery()
                    q.type = this.typeSub.value
                    q.scope = this.typeMain.value
                    q.query = this.treeMain.activeItem.Title
                    q.execute(function(db){tree.load(db,tree)})
                    ]]>
                </body>
            </method>
        </implementation>
    </binding>

    <binding id="mpdBrowser">
        <content>
            <xul:vbox flex="1">
                <xul:toolbar align="center">
                    <xul:deck id="toolbar_deck">
                        <xul:hbox>
                            <xul:toolbarbutton tooltiptext="Update Database"
                                class="mpm_btn_Update"
                                oncommand="mpd.doCmd('update')"/>
                            <xul:toolbarbutton label="All"
                                class="mpm_btn_AddAll"
                                oncommand="this.parentNode.parentNode.parentNode.parentNode.browser.addAll()"/>
                            <xul:toolbarbutton label="Selected"
                                class="mpm_btn_AddSelected"
                                oncommand="this.parentNode.parentNode.parentNode.parentNode.browser.addSelected()"/>
                        </xul:hbox>
                        <xul:hbox>
                            <xul:toolbarbutton label="Clear Playlist "
                                class="mpm_btn_Clear"
                                oncommand="mpd.doCmd('clear')"/>
                            <xul:textbox id="plname"
                                value="Playlist Name"
                                flex="1"
                                maxwidth="250"/>
                            <xul:toolbarbutton tooltiptext="Save Playlist"
                                class="mpm_btn_Save"
                                oncommand='var n=this.parentNode.childNodes[1].value;if(!n)return null;mpd.doCmd("save "+String.fromCharCode(34)+n.replace(/"/g,String.fromCharCode(39))+String.fromCharCode(34))'/>
                        </xul:hbox>
                    </xul:deck>
                    <xbl:children includes="toolbarbutton"/>
                    <xul:spacer flex="1"/>
                    <xul:menulist id="searchType"
                        label="Search"
                        sizetopopup="always"
                        onselect="this.parentNode.parentNode.parentNode.searchTypeSelect()"
                        persist="selectedItem">
                        <xul:menupopup>
                            <xul:menuitem label="Filter"
                                tooltiptext="Filter contents of current location by Title column"/>
                            <xul:menuitem label="Search All"
                                tooltiptext="Search songs on all fields"
                                selected="true"/>
                            <xul:menuitem label="Playlist"
                                tooltiptext="Search in Playlist on all fields"/>
                            <xul:menuitem label="Title"
                                tooltiptext="Search by song's Title only"/>
                            <xul:menuitem label="Artist"
                                tooltiptext="Search Artists"/>
                            <xul:menuitem label="Album"
                                tooltiptext="Search Albums"/>
                            <xul:menuitem label="Genre"
                                tooltiptext="Search Genres"/>
                            <xul:menuitem label="Composer"
                                tooltiptext="Search Composers"/>
                            <xul:menuitem label="Performer"
                                tooltiptext="Search Performers"/>
                            <xul:menuitem label="Date"
                                tooltiptext="Search Release Years"/>
                        </xul:menupopup>
                    </xul:menulist>
                    <xul:textbox id="searchInput"
                        type="timed"
                        timeout="200"
                        onenter="this.oncommand()"
                        oncommand="this.parentNode.parentNode.parentNode.handleSearch()"/>
                </xul:toolbar>
                <xul:deck id="mpm_browser_deck" flex="1">
                    <xul:hbox flex="1">
                        <xul:tabbox width="200px"
                            id="browserTabbox"
                            persist="selectedTab selectedItem selectedPanel">
                            <xul:tabs>
                                <xul:tab label="Folders" id="folders_tab" flex="1"/>
                                <xul:tab label="Playlists" id="playlist_tab" flex="1"/>
                                <xul:tab label="Tags" id="tags_tab" flex="1"/>
                            </xul:tabs>
                            <xul:tabpanels flex="1">
                                <xul:tabpanel flex="1">
                                    <xul:box id="folders"
                                        flex="1"
                                        minwidth="100px"
                                        style="-moz-binding: url('#mpmFoldersPane')"/>
                                </xul:tabpanel>
                                <xul:tabpanel flex="1">
                                    <xul:box id="playlists"
                                        flex="1"
                                        minwidth="100px"
                                        style="-moz-binding: url('#mpmList')"/>
                                </xul:tabpanel>
                                <xul:tabpanel flex="1">
                                    <xul:box id="tags"
                                        flex="1"
                                        minwidth="100px"
                                        style="-moz-binding: url('#mpmTagsPane')"/>
                                </xul:tabpanel>
                            </xul:tabpanels>
                        </xul:tabbox>
                        <xul:splitter collapse="before"/>
                        <xul:vbox flex="1" style="overflow:hidden">
                            <xul:hbox class="mpm_navbar" align="center">
                                <xul:toolbarbutton class="mpm_btn_Back"
                                    tooltiptext="Back"
                                    oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goBack()"/>
                                <xul:toolbarbutton class="mpm_btn_Forward"
                                    tooltiptext="Forward"
                                    oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goForward()"/>
                                <xul:toolbarbutton class="mpm_btn_Home"
                                    tooltiptext="Home"
                                    oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.goHome()"/>
                                <xul:toolbarseparator/>
                                <xul:image id="cwd_icon"/>
                                <xul:label id="cwd" class="cwd" crop="start" flex="1"/>
                            </xul:hbox>
                            <xul:hbox flex="1" id="mpm_browser_browser" style="overflow:auto">
                                <xul:vbox class="mpm_browser_image_box">
                                    <xul:label id="detail_label" class="fake_treecol" crop="end" value="Item"/>
                                    <xul:image id="image" class="mpm_browser_image"
                                               validate="never"
                                               ondblclick="switch(this.className){case 'mpm_browser_image':this.className='mpm_browser_image_large';break;case 'mpm_browser_image_large':this.className='mpm_browser_image_small';break;default:this.className='mpm_browser_image'}"/>
                                    <xbl:children includes="vbox"/>
                                    <xul:spacer flex="1"/>
                                </xul:vbox>
                                <xul:deck id="browser-playlist_deck" flex="1"
                                onselect="me.tdeck.selectedIndex=this.selectedIndex">
                                    <xul:box id="browser" class="mpm_browser" flex="1"
                                             style="-moz-binding: url('#mpmBrowser')"/>
                                    <xul:box id="playlist" flex="1"
                                             mpm_name="browser_playlist"
                                             style="-moz-binding: url('chrome://minion/content/playlistBindings.xml#mpdPlaylist')"/>
                                    <xbl:children includes="mpdplaylist"/>
                                </xul:deck>
                            </xul:hbox>
                        </xul:vbox>
                    </xul:hbox>
                    <xul:vbox>
                        <xul:toolbar class="mpm_navbar" align="center">
                            <xul:toolbarbutton class="mpm_btn_Back"
                                tooltiptext="Back to Music Collection"
                                oncommand="this.parentNode.parentNode.parentNode.selectedIndex=0"/>
                            <xul:toolbarseparator/>
                            <xul:image class="mpm_icon_file"/>
                            <xul:label id="file_details" class="cwd" crop="start" flex="1"/>
                        </xul:toolbar>
                        <xul:browser id="mpm_browser_content" style="overflow:auto" flex="1"/>
                    </xul:vbox>
                </xul:deck>
            </xul:vbox>
        </content>
        <implementation>
            <field name="searchType">document.getAnonymousElementByAttribute(this, 'id', 'searchType')</field>
            <field name="searchInput">document.getAnonymousElementByAttribute(this, 'id', 'searchInput')</field>
            <field name="history">new Array()</field>
            <field name="historyRows">new Array()</field>
            <field name="historyIndex">0</field>
            <field name="obsCurSong"/>
            <field name="browser">document.getAnonymousElementByAttribute(this, 'id', 'browser')</field>
            <field name="playlist">document.getAnonymousElementByAttribute(this, 'id', 'playlist')</field>
            <field name="bp_deck">document.getAnonymousElementByAttribute(this, 'id', 'browser-playlist_deck')</field>
            <field name="deck">document.getAnonymousElementByAttribute(this, 'id', 'mpm_browser_deck')</field>
            <field name="tdeck">document.getAnonymousElementByAttribute(this, 'id', 'toolbar_deck')</field>
            <field name="content">document.getAnonymousElementByAttribute(this, 'id', 'mpm_browser_content')</field>
            <field name="detail_label">document.getAnonymousElementByAttribute(this, 'id', 'detail_label')</field>
            <field name="image">document.getAnonymousElementByAttribute(this, 'id', 'image')</field>
            <field name="cwd">document.getAnonymousElementByAttribute(this, 'id', 'cwd')</field>
            <field name="fileDetails">document.getAnonymousElementByAttribute(this, 'id', 'file_details')</field>
            <field name="cwd_icon">document.getAnonymousElementByAttribute(this, 'id', 'cwd_icon')</field>
            <field name="folders">document.getAnonymousElementByAttribute(this, 'id', 'folders')</field>
            <field name="folders_tab">document.getAnonymousElementByAttribute(this, 'id', 'folders_tab')</field>
            <field name="playlists">document.getAnonymousElementByAttribute(this, 'id', 'playlists')</field>
            <field name="plname">document.getAnonymousElementByAttribute(this, 'id', 'plname')</field>
            <field name="playlist_tab">document.getAnonymousElementByAttribute(this, 'id', 'playlist_tab')</field>
            <field name="tags_tab">document.getAnonymousElementByAttribute(this, 'id', 'tags_tab')</field>
            <field name="sidebar">document.getAnonymousElementByAttribute(this, 'id', 'sidebar')</field>
            <field name="tabbox">document.getAnonymousElementByAttribute(this, 'id', 'browserTabbox')</field>
            <field name="tags">document.getAnonymousElementByAttribute(this, 'id', 'tags')</field>
            <constructor>
                <![CDATA[
                Components.utils.import("resource://minion/mpd.js");
                Components.utils.import("resource://minion/trees.js");
                Components.utils.import("resource://minion/io.js");

                var me = this
                this.deck.me = me
                var searchInput = this.searchInput
                function searchInputSet () {
                    var t = prefs.get("search_timeout",200)
                    if (t == 0) t = null
                    searchInput.setAttribute("timeout", t)
                }
                searchInputSet()
                var obsSearchInput = prefs.getObserver("search_timeout", searchInputSet)
                
                var url = prefs.get("song_template", "chrome://minion/content/default_song_template.xul")
                this.content.setAttribute("src", url);
                this.cwin = Nz(this.content.contentWindow.wrappedJSObject, this.content.contentWindow)
                this.cwin.followItem = function(i, f, q) {me.followItem(i, f, q)}
                
                var browser = this.browser
                var playlist = this.playlist
                var albumCol = browser.treeNode.columns.getNamedColumn("AlbumCover").element
                var image = this.image
                var folders = this.folders
                var playlists = this.playlists
                var tags = this.tags

                me.handle_select = function(){}
                browser.goTo = function(q) {me.goTo(q)}
                browser.followItem = function(i, f, q) {me.followItem(i, f, q)}
                folders.goTo = function(q) {me.goTo(q)}
                folders.followItem = function(i, f, q) {me.followItem(i, f, q)}
                this.selectChange = function (item, location) {
                    debug("selectChange")
                    var item = Nz(item, me.getActiveItem())
                    var location = Nz(location, me.getActiveLocation())
                    image.removeAttribute("tooltiptext")
                    if (item) {
                        if (item.type=='search') {
                            detail_label.value = "Search "+item.Title
                                var s = "chrome://minion/content/images/"
                                me.image.src = s + item.Title.toLowerCase() + "_xlarge.png"
                                me.image.className='mpm_browser_image_small'
                        }
                        else {
                            detail_label.value = item.Title
                            if (item.type == 'file') {
                                mpd.getArt(item, image)
                                me.image.className='mpm_browser_image'
                            } else {
                                var s = "chrome://minion/content/images/"
                                me.image.src = s + item.type.toLowerCase() + "_xlarge.png"
                                me.image.className='mpm_browser_image_small'
                            }
                        }
                    } else {
                        me.image.src = ""
                        me.image.className='mpm_browser_image_small'
                    }        
                    me.handle_select(item, location)
                }
                browser.treeNode.addEventListener("select",
                    function(){
                        var a = browser.activeItem
                        var l = "mpdbrowser"
                        if (Nz(a.name)=='Current Playlist') var l = "mpdplaylist"
                        selectChange(a, l)
                    }, false)
                playlist.tree.addEventListener("select",
                    function(){selectChange(playlist.activeItem, "mpdplaylist")}, false)
                this.folders_tab.onclick = function () {
                    if (!Nz(folders.db)) {
                        mpd.getAllDirs(function(db){
                            folders.load(db, folders)
                        })
                    }
                }
                playlists.goTo = function(q) {me.goTo(q)}
                playlists.followItem = function(i, f, q) {me.followItem(i, f, q)}
                this.playlist_tab.onclick = function () {
                    var q = new dbQuery()
                    q.type = "playlist"
                    q.query = ""
                    q.execute(function(db){
                        var cur = {
                            type: "playlist",
                            name: "Current Playlist",
                            Title: "Current Playlist"
                        }
                        db.unshift(cur)
                        playlists.load(db,playlists)
                    })
                    me.goTo({query:'Current Playlist'})
                }
                this.tags_tab.onclick = function () {
                    //if (!Nz(tags.db)) tags.loadMain()
                }

                tags.treeMain.followItem = function(i){debug("treeMain.followItem()");me.followItem(i)}
                tags.treeSub.followItem = function(i){
                    var f = tags.treeMain.activeItem
                    me.followItem(i, f.type, f.name)
                }

                var heirs = {
                    directory: 'directory',
                    genre: 'artist',
                    artist: 'album',
                    performer: 'album',
                    composer: 'album',
                    date: 'album',
                    album: 'file'
                }

                this.observerUpdate = {
                    observe: function(subject,topic,data){
                        if (!data) me.reload()
                        else {
                            browser.box.clearStyleAndImageCaches()
                            browser.box.invalidate()
                        }
                    }
                };
                observerService.addObserver(this.observerUpdate,"updating_db",false)
                observerService.addObserver(this.observerUpdate,"song",false)
                observerService.addObserver(this.observerUpdate,"state",false)
                observerService.addObserver(this.observerUpdate,"plinfo",false)
                this.observerServer = {
                    observe: function(subject,topic,data){
                        me.goHome()
                    }
                };
                observerService.addObserver(this.observerServer,"new_mpd_server",false)
                this.observerPlaylists = {
                    observe: function(subject,topic,data){
                        var q = new dbQuery()
                        q.type = "playlist"
                        q.query = ""
                        q.execute(function(db){
                            var cur = {
                                type: "playlist",
                                name: "Current Playlist",
                                Title: "Current Playlist"
                            }
                            db.unshift(cur)
                            playlists.load(db,playlists)
                        })
                    }
                };
                observerService.addObserver(this.observerPlaylists,"playlists",false)

                this.observerPlaylistName = {
                    observe: function(subject,topic,data){
                        me.plname.value = data
                    }
                };
                observerService.addObserver(this.observerPlaylistName,"load_playlist",false)
                
                var bcols = browser.treeNode.childNodes[0].childNodes
                var colprops = prefs.get("browser_columns", "")
                function setCol(val, index, arr) {
                    props = val.split(":")
                    if (props[0] > "") {
                        var c = document.getAnonymousElementByAttribute(browser.treeNode, 'id', props[0])
                        c.hidden = (props[1]=="true")
                        c.setAttribute("width", props[2])
                        c.setAttribute("ordinal", props[3])
                    }
                }
                if (colprops > "") {
                    var cols = colprops.split(";")
                    cols.forEach(setCol, cols)
                }
                image.parentNode.collapsed=albumCol.hidden
                albumCol.collapsed = true
                
                me.goHome()
                if (prefs.get("persistant_state", true)) {
                    try {
                        var file = DirIO.get("Home")
                        file.append(".mpm_browser_state.js")
                        if (file.exists()) {
                            var cache_browser = eval(FileIO.read(file))
                            tabbox.selectedIndex = cache_browser.activeTab
                            if (cache_browser.db_update == mpd.db_update) {
                                folders.db = cache_browser.foldersDB
                                folders.view = new folderView(cache_browser.foldersDB, cache_browser.foldersRS);
                                folders.treeNode.view = folders.view;
                                folders.treeNode.currentIndex = cache_browser.foldersIndex
                                if (cache_browser.activeTab == 0)
                                    folders.treeNode.view.selection.select(cache_browser.foldersIndex)
                            }
                            tabbox.selectedTab.onclick()
                            file = null
                        }
                    } catch (e) {
                        tabbox.selectedIndex = 0
                        tabbox.selectedTab.onclick()
                    }
                } else {
                    tabbox.selectedIndex = 0
                    tabbox.selectedTab.onclick()
                }
                albumCol.addEventListener("DOMAttrModified", function(){image.parentNode.collapsed=albumCol.hidden;albumCol.collapsed=true}, false)
                ]]>
            </constructor>
            <destructor>
                <![CDATA[
                
                if (prefs.get("persistant_state", true)) {
                    var file = DirIO.get("Home")
                    file.append(".mpm_browser_state.js")
                    if (!file.exists()) FileIO.create(file)
                    var tree = folders.treeObject
                    var obj = {
                        activeTab: tabbox.selectedIndex,
                        db_update: mpd.db_update,
                        foldersDB: folders.view.db,
                        foldersRS: folders.view.rs,
                        foldersIndex: folders.treeNode.currentIndex
                    }
                    var str = obj.toSource()
                    FileIO.write(file, str)
                    file = null
                }
                this.saveColumns()
                observerService.removeObserver(this.observerUpdate,"updating_db")
                observerService.removeObserver(this.observerUpdate,"song")
                observerService.removeObserver(this.observerUpdate,"state")
                observerService.removeObserver(this.observerUpdate,"plinfo")
                observerService.removeObserver(this.observerServer,"new_mpd_server")
                observerService.removeObserver(this.observerPlaylists,"playlists")
                observerService.removeObserver(this.observerPlaylistName,"load_playlist")
                ]]>
            </destructor>
            <method name="addSelected">
                <body>
                    var e = document.commandDispatcher.focusedElement.parentNode
                    e.addSelected()
                </body>
            </method>
            <method name="doUpdate">
                <body>
                    <![CDATA[
                    try {
                        var cmd = "update"
                        var cwd = this.history[this.historyIndex]
                        if (cwd.type=='directory') cmd = "update "+Sz(cwd.query)
                        mpd.doCmd(cmd)
                    } catch(e){debug(e)}
                    ]]>
                </body>
            </method>
            <method name="followItem">
                <parameter name="item"/>
                <parameter name="filterField"/>
                <parameter name="filterQuery"/>
                <body>
                    <![CDATA[
                    try {
                    var q = new dbQuery()
                    q.type = item.type
                    switch (item.type) {
                        case 'file':
                            var act = parseInt(prefs.get("default_file_action", 0))
                            
                            if (act==0) {
                                // Prompt
                                mpm_openDialog('chrome://minion/content/fileActions.xul', 'mpm_file_actions')
                                var act = parseInt(prefs.get("default_file_action", 0))
                            }

                            switch (act) {
                                case 1:
                                    // Add to Playlist
                                    mpd.addToPlaylist(item)    
                                    return null;                                
                                    break;
                                case 2:
                                    //Add to Playlist and Play Now
                                    var l = mpd.playlistlength
                                    mpd.addToPlaylist(item)
                                    mpd.doCmd("play " + l)
                                    return null;
                                    break;
                                case 3:
                                    //Add to Playlist and Play if stopped
                                    var l = mpd.playlistlength
                                    mpd.addToPlaylist(item)
                                    if (mpd.state == 'stop') mpd.doCmd("play " + l)
                                    return null;
                                    break;
                                case 4:
                                    //View Song Details
                                    this.cwin.load(item);
                                    this.fileDetails.value = item.file;
                                    this.deck.selectedIndex =1;
                                    return null;
                            }
                            break;
                        case 'directory': break;
                        case 'playlist': break;
                        default:
                            if (Nz(item.name,"") > "") {
                                q.type = 'file';
                                q.scope = item.type;
                                q.filterField = Nz(filterField)
                                q.filterQuery = Nz(filterQuery)
                            }
                            break;
                    }
                    q.query = item.name
                    this.goTo(q, item)
                    } catch(e){debug(e)}
                    ]]>
                </body>
            </method>
            <method name="getActiveBrowser">
                <body>
                    <![CDATA[
                    var e = document.commandDispatcher.focusedElement.parentNode
                    return Nz(e)
                    ]]>
                </body>
            </method>
            <method name="getActiveLocation">
                <body>
                    <![CDATA[
                    if (this.bp_deck.selectedIndex==0) {
                        var a = this.browser.activeItem
                        var l = "mpdbrowser"
                        if (a && Nz(a.name)=='Current Playlist') var l = "mpdplaylist"
                        return l
                    } else {
                        return "mpdplaylist"
                    }
                    ]]>
                </body>
            </method>
            <method name="getActiveItem">
                <body>
                    <![CDATA[
                    var f = document.commandDispatcher.focusedElement
                    if (!f) {debug("No focused Element!");return null}
                    var e = f.parentNode
                    if (!e) {debug("No parentNode!");return null}
                    var a = Nz(e.activeItem)
                    if (!a) {debug("No activeItem!");return null}
                    return a
                    ]]>
                </body>
            </method>
            <method name="goBack">
                <body>
                    if (this.historyIndex >= (this.history.length-1)) return null
                    this.historyIndex++
                    this.goTo(this.history[this.historyIndex])
                    atRow = this.historyRows[this.historyIndex]
                    this.browser.treeNode.currentIndex = atRow
                    this.browser.box.scrollToRow(atRow)
                </body>
            </method>
            <method name="goForward">
                <body>
                    if (this.historyIndex == 0) return null
                    this.historyIndex--
                    this.goTo(this.history[this.historyIndex])
                    atRow = this.historyRows[this.historyIndex]
                    this.browser.treeNode.currentIndex = atRow
                    this.browser.box.scrollToRow(atRow)
                </body>
            </method>
            <method name="goHome">
                <body>
                    this.deck.selectedIndex = 0
                    this.goTo(null)
                </body>
            </method>
            <method name="goTo">
                <parameter name="query"/>
                <parameter name="followitem"/>
                <body>
                    <![CDATA[
                    query = Nz(query)
                    var me = this
                    this.browser.box.QueryInterface(Components.interfaces.nsITreeBoxObject)
                    if (query && query.query != 'Current Playlist') {
                        this.deck.selectedIndex = 0
                        this.bp_deck.selectedIndex = 0
                        var browser = this.browser
                        var albumCol = browser.getCol('Album')
                        query.callBack = function (db) {
                            if (Nz(query.type)=='playlist' && Nz(query.query)=='') {
                                var cur = {
                                    type: "playlist",
                                    name: "Current Playlist",
                                    Title: "Current Playlist"
                                }
                                db.unshift(cur)
                            }
                            browser.load(db);
                            me.cwd.value = query.query.split("/").slice(-1)
                            if (Nz(query.filterField)) me.cwd.value += " ("+query.filterField + ": " + query.filterQuery + ")"
                            me.cwd_icon.className = "mpm_icon_"
                            if (query.type != "search") browser.collapseOne(query.scope)
                            else browser.collapseOne(null)
                            me.cwd_icon.className += query.scope
                            if (Nz(followitem)) {
                                me.selectChange(followitem, "mpdbrowser")
                            } else {
                                me.selectChange()
                            }
                        }
                        query.execute()
                    }
                    else if (query && query.query == 'Current Playlist') {
                        me.deck.selectedIndex = 0
                        me.bp_deck.selectedIndex = 1
                        me.cwd.value = 'Current Playlist'
                        me.cwd_icon.className = 'mpm_icon_playlist'
                        var pos = parseInt(Nz(mpd.song,0))
                        me.selectChange()
                        //me.playlist.tree.view.selection.select(pos)                    
                    }
                    else {
                        var home = [
                            {
                                type: 'directory',
                                Title: 'Folders',
                                name: ''
                            },
                            {
                                type: 'Artist',
                                Title: 'Artists',
                                name: ''
                            },
                            {
                                type: 'Album',
                                Title: 'Albums',
                                name: ''
                            },
                            {
                                type: 'playlist',
                                Title: 'Playlists',
                                name: ''
                            }
                        ]
                        this.browser.load(home)
                        me.selectChange()
                    }
                    if (!query) return null
                    if (query.type.indexOf("search") < 0 ) {
                        if (this.history[this.historyIndex] != query) {
                            this.history.splice(this.historyIndex,0,query)
                            this.historyRows.splice(this.historyIndex,0,this.browser.box.getFirstVisibleRow())
                            debug(this.historyIndex)
                            debug(this.historyRows)
                            debug([x.query for each (x in this.history)])
                        }
                    }
                    ]]>
                </body>
            </method>
            <method name="handleSearch">
                <body>
                    <![CDATA[
                    var q = new dbQuery()
                    q.type = "search"
                    q.scope = this.searchType.selectedItem.label
                    q.query = this.searchInput.value

                    switch (q.scope) {
                        case "Search All": q.scope = "any"; break;
                        case "Playlist": q.type = "playlistsearch"; q.scope = "any";break;
                        case "Filter": this.browser.applyFilter(this.searchInput.value); return null; break;
                    }
                    this.goTo(q, {type:"search", Title:q.scope, name:q.scope})
                    ]]>
                </body>
            </method>
            <method name="searchTypeSelect">
                <body>
                    <![CDATA[
                    if (this.searchType.selectedItem.label == 'Filter') {
                        this.searchInput.select()
                    }
                    else {
                        if (this.searchInput.value.length > 0) this.handleSearch()
                    }
                    this.searchInput.focus()
                    ]]>
                </body>
            </method>
            <method name="reload">
                <body>
                    var query = this.history[this.historyIndex]
                    if (query) {
                        var browser = this.browser
                        query.callBack = function (db) {
                            browser.load(db);
                        }
                        query.execute()
                    }
                </body>
            </method>
            <method name="saveColumns">
                <body>
                    <![CDATA[
                    this.browser.saveCols()
                    ]]>
                </body>
            </method>
            <method name="showDetails">
                <parameter name="item"/>
                <body>
                    <![CDATA[
                        var win = this.cwin
                        win.load(item);
                        this.fileDetails.value = item.file;
                        this.deck.selectedIndex =1;
                    ]]>
                </body>
            </method>
        </implementation>
    </binding>

</bindings>
